"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockDataEntitySet = void 0;
const path_1 = require("path");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const fileBasedMockData_1 = require("../../mockdata/fileBasedMockData");
const functionBasedMockData_1 = require("../../mockdata/functionBasedMockData");
const odataRequest_1 = __importDefault(require("../../request/odataRequest"));
const common_1 = require("../common");
function makeTransformationFn(type, preparedArgs) {
    return function (mockData) {
        const resolvedArgs = preparedArgs.map((preparedArg) => preparedArg.fn(mockData));
        return transformationFn(type, resolvedArgs[1])(resolvedArgs[0]);
    };
}
function transformationFn(type, check) {
    switch (type) {
        case 'tolower':
            return (data) => data.toLowerCase();
        case 'toupper':
            return (data) => data.toUpperCase();
        case 'trim':
            return (data) => data.trim();
        case 'length':
            return (data) => {
                return data && data.length;
            };
        case 'round':
            return (data) => Math.round(parseFloat(data));
        case 'floor':
            return (data) => Math.floor(parseFloat(data));
        case 'ceiling':
            return (data) => Math.ceil(parseFloat(data));
        case 'cast':
            return (data) => {
                switch (check) {
                    case 'Edm.String':
                        return data.toString();
                    case 'Edm.Boolean':
                        return data === 'true';
                    case 'Edm.Byte':
                    case 'Edm.Int16':
                    case 'Edm.Int32':
                    case 'Edm.Int64': {
                        return parseInt(data, 10);
                    }
                    case 'Edm.Decimal': {
                        return parseFloat(data);
                    }
                    default:
                        return data;
                }
            };
        case 'startswith':
            return (data) => {
                return data.startsWith(prepareLiteral(check, 'Edm.String'));
            };
        case 'endswith':
            return (data) => {
                return data.endsWith(prepareLiteral(check, 'Edm.String'));
            };
        case 'substringof':
            return (data) => {
                return check.indexOf(prepareLiteral(data, 'Edm.String')) !== -1;
            };
        case 'contains':
            return (data) => {
                return data.indexOf(prepareLiteral(check, 'Edm.String')) !== -1;
            };
        case 'concat':
            return (data) => {
                return data + prepareLiteral(check, 'Edm.String');
            };
        case 'indexof':
            return (data) => {
                return data.indexOf(prepareLiteral(check, 'Edm.String'));
            };
        case 'substring':
            return (data) => {
                return data.substring(check);
            };
        case 'matchesPattern':
            const regExp = new RegExp(prepareLiteral(check, 'Edm.String'));
            return (data) => {
                return regExp.test(data);
            };
        case 'getData':
            return (data) => {
                return (0, common_1.getData)(data, check);
            };
        case 'noop':
        default:
            return (data) => data;
    }
}
function prepareLiteral(literal, propertyType) {
    if (!literal) {
        return literal;
    }
    switch (propertyType) {
        case 'Edm.Boolean':
            return literal === 'true';
        case 'Edm.String':
        case 'Edm.Guid':
            if (literal && literal.startsWith("'")) {
                return literal.substring(1, literal.length - 1);
            }
            else {
                return literal;
            }
        case 'Edm.Byte':
        case 'Edm.Int16':
        case 'Edm.Int32':
        case 'Edm.Int64': {
            return parseInt(literal, 10);
        }
        case 'Edm.Decimal': {
            return parseFloat(literal);
        }
        default:
            return literal;
    }
}
/**
 *
 */
class MockDataEntitySet {
    static async read(mockDataRootFolder, entity, generateMockData, isDraft, dataAccess) {
        const path = (0, path_1.join)(mockDataRootFolder, entity) + '.json';
        const jsPath = (0, path_1.join)(mockDataRootFolder, entity) + '.js';
        let outData = [];
        let isInitial = true;
        dataAccess.log.info(`Trying to find ${jsPath} for mockdata`);
        if (await dataAccess.fileLoader.exists(jsPath)) {
            try {
                //eslint-disable-next-line
                outData = await dataAccess.fileLoader.loadJS(jsPath);
                isInitial = false;
                dataAccess.log.info('JS file found for ' + entity);
            }
            catch (e) {
                console.error(e);
                return Promise.resolve([]);
            }
        }
        if ((isInitial || !outData.getInitialDataSet) && (await dataAccess.fileLoader.exists(path))) {
            dataAccess.log.info(`Trying to find ${path} for mockdata`);
            try {
                const fileContent = await dataAccess.fileLoader.loadFile(path);
                let outJsonData;
                if (fileContent.length === 0) {
                    outJsonData = [];
                }
                else {
                    outJsonData = JSON.parse(fileContent);
                    outJsonData.forEach((jsonLine) => {
                        if (isDraft) {
                            const IsActiveEntityValue = jsonLine.IsActiveEntity;
                            if (IsActiveEntityValue === undefined) {
                                jsonLine.IsActiveEntity = true;
                                jsonLine.HasActiveEntity = true;
                                jsonLine.HasDraftEntity = false;
                            }
                        }
                        delete jsonLine['@odata.etag'];
                    });
                }
                dataAccess.log.info(`JSON file found for ${entity}`);
                if (isInitial) {
                    outData = outJsonData;
                    isInitial = false;
                }
                else {
                    outData.getInitialDataSet = function () {
                        return outJsonData.concat();
                    };
                }
            }
            catch (e) {
                dataAccess.log.info(e);
            }
        }
        if (isInitial) {
            outData = [];
            if (generateMockData) {
                outData.__generateMockData = generateMockData;
            }
        }
        return outData;
    }
    /**
     * @param rootFolder
     * @param entitySetDefinition
     * @param dataAccess
     * @param generateMockData
     * @param initializeMockData
     * @param isDraft
     */
    constructor(rootFolder, entitySetDefinition, dataAccess, generateMockData, initializeMockData = true, isDraft = false) {
        this._rootMockData = [];
        this.contextBasedMockData = {};
        if (entitySetDefinition._type === 'EntityType') {
            this.entitySetDefinition = null;
            this.entityTypeDefinition = entitySetDefinition;
        }
        else {
            this.entitySetDefinition = entitySetDefinition;
            this.entityTypeDefinition = this.entitySetDefinition.entityType;
        }
        this.dataAccess = dataAccess;
        if (initializeMockData) {
            this.readyPromise = MockDataEntitySet.read(rootFolder, entitySetDefinition.name, generateMockData, isDraft, dataAccess).then((mockData) => {
                if (typeof mockData === 'object' && !Array.isArray(mockData)) {
                    this._rootMockDataFn = mockData;
                }
                else {
                    this._rootMockData = mockData;
                }
                return this;
            });
        }
    }
    getMockData(contextId) {
        if (!Object.prototype.hasOwnProperty.apply(this.contextBasedMockData, [contextId])) {
            this.contextBasedMockData[contextId] = this._rootMockDataFn
                ? new functionBasedMockData_1.FunctionBasedMockData(this._rootMockDataFn, this.entityTypeDefinition, this, contextId)
                : new fileBasedMockData_1.FileBasedMockData(this._rootMockData, this.entityTypeDefinition, this, contextId);
        }
        else {
            this.contextBasedMockData[contextId].cleanupHierarchies();
        }
        return this.contextBasedMockData[contextId];
    }
    checkKeys(keyValues, dataLine, keyDefinition) {
        return Object.keys(keyValues).every((keyName) => {
            return this.checkKeyValue(dataLine, keyValues, keyName, keyDefinition.find((keyProp) => keyProp.name === keyName));
        });
    }
    checkSpecificProperties(_filterExpression, _mockData, _allData, _odataRequest) {
        return null;
    }
    isV4() {
        return this.dataAccess.isV4();
    }
    getProperty(identifier) {
        let resolvedPath;
        if (this.entitySetDefinition) {
            resolvedPath = this.dataAccess
                .getMetadata()
                .resolvePath('/' + this.entitySetDefinition.name + '/' + identifier);
        }
        else {
            resolvedPath = this.entityTypeDefinition.resolvePath(identifier, true);
        }
        return resolvedPath.target;
    }
    checkFilter(mockData, filterExpression, tenantId, odataRequest) {
        let isValid = true;
        if (filterExpression.hasOwnProperty('expressions')) {
            if (filterExpression.operator === 'AND') {
                isValid = filterExpression.expressions.every((filterValue) => {
                    return this.checkFilter(mockData, filterValue, tenantId, odataRequest);
                });
            }
            else {
                isValid = filterExpression.expressions.some((filterValue) => {
                    return this.checkFilter(mockData, filterValue, tenantId, odataRequest);
                });
            }
        }
        else {
            isValid = this.checkSimpleExpression(filterExpression, mockData, tenantId, odataRequest);
        }
        return isValid;
    }
    createTransformation(identifier) {
        if (typeof identifier === 'string') {
            const property = this.getProperty(identifier);
            if (property) {
                return { fn: transformationFn('getData', identifier), type: property.type };
            }
            return { fn: () => identifier, type: 'Edm.String' };
        }
        else {
            const methodArgTransformed = identifier.methodArgs.map((methodArg) => this.createTransformation(methodArg));
            const comparisonType = identifier.method === 'length' || identifier.method === 'indexof' ? 'Edm.Int16' : 'Edm.String';
            return { fn: makeTransformationFn(identifier.method, methodArgTransformed), type: comparisonType };
        }
    }
    checkSimpleExpression(filterExpression, mockData, tenantId, odataRequest) {
        const identifier = filterExpression.identifier;
        const operator = filterExpression.operator;
        const literal = filterExpression.literal;
        if (identifier.type === 'lambda') {
            return this.checkLambdaExpression(identifier, transformationFn('noop'), mockData, tenantId, odataRequest);
        }
        let identifierFn = this.createTransformation(identifier);
        let literalFn = {
            fn: makeTransformationFn('noop', [{ fn: () => true, type: 'Edm.Boolean' }]),
            type: 'Edm.Boolean'
        };
        if (literal) {
            literalFn = this.createTransformation(literal);
        }
        let property;
        if (filterExpression.propertyPath) {
            // We're possibly in a lambda operation so let's try to see if the first part is a real property
            property = this.getProperty(filterExpression.propertyPath);
            identifierFn = { fn: transformationFn('getData', identifier), type: property.type };
        }
        const currentMockData = this.getMockData(tenantId);
        const specificCheck = this.checkSpecificProperties(filterExpression, mockData, currentMockData, odataRequest);
        if (specificCheck !== null) {
            return specificCheck;
        }
        const mockValue = identifierFn.fn(mockData);
        const literalValue = literalFn.fn(mockData);
        const comparisonType = identifierFn.type;
        if (literal === undefined) {
            return mockValue === true;
        }
        return currentMockData.checkFilterValue(comparisonType, mockValue, literalValue, operator, odataRequest);
    }
    checkLambdaExpression(expression, identifierTransformation, mockData, tenantId, odataRequest) {
        let mockDataToCheckValue = identifierTransformation((0, common_1.getData)(mockData, expression.target));
        if (!Array.isArray(mockDataToCheckValue)) {
            mockDataToCheckValue = [mockDataToCheckValue];
        }
        if (expression.expression.expressions) {
            expression.expression.expressions.forEach((entry) => {
                const replaceValue = expression.propertyPath || expression.target;
                if (typeof entry.identifier === 'string') {
                    entry.propertyPath = entry.identifier.replace(expression.key, replaceValue);
                }
                else {
                    entry.identifier.propertyPath = entry.identifier.target.replace(expression.key, replaceValue);
                }
            });
        }
        const check = (subMockData) => {
            let mockDataToCheck = subMockData;
            if (expression.key && expression.key.length > 0) {
                mockDataToCheck = { [expression.key]: subMockData };
            }
            return this.checkFilter(mockDataToCheck, expression.expression, tenantId, odataRequest);
        };
        switch (expression.operator) {
            case 'ALL':
                return mockDataToCheckValue.every(check);
            case 'ANY':
                return mockDataToCheckValue.some(check);
        }
    }
    checkSearch(mockData, searchQueries, _odataRequest) {
        const currentMockData = this.getMockData(_odataRequest.tenantId);
        const searchableProperties = this.entityTypeDefinition.entityProperties.filter((property) => {
            switch (property.type) {
                case 'Edm.Boolean':
                case 'Edm.Int32':
                    return false;
                case 'Edm.String':
                    return true;
                default:
                    return false;
            }
        });
        return searchQueries.every((searchQuery) => {
            return searchableProperties.some((property) => {
                const mockValue = mockData[property.name];
                return currentMockData.checkSearchQuery(mockValue, searchQuery, _odataRequest);
            });
        });
    }
    checkKeyValue(mockData, keyValues, keyName, keyProp) {
        if (keyProp) {
            switch (keyProp.type) {
                case 'Edm.Guid':
                    if (keyValues[keyName] && keyValues[keyName].startsWith("guid'")) {
                        return mockData[keyName] === keyValues[keyName].substring(5, keyValues[keyName].length - 1);
                    }
                    return mockData[keyName] === keyValues[keyName];
                case 'Edm.String':
                case 'Edm.Boolean':
                    return mockData[keyName] === keyValues[keyName];
                case 'Edm.Int32':
                case 'Edm.Int64':
                case 'Edm.Int16':
                    return mockData[keyName] === parseInt(keyValues[keyName], 10);
                default:
                    return mockData[keyName] === keyValues[keyName];
            }
        }
        return mockData[keyName] === keyValues[keyName];
    }
    getKeys(dataLine) {
        const keys = this.entityTypeDefinition.keys;
        const keyValues = {};
        keys.forEach((keyProp) => {
            keyValues[keyProp.name] = dataLine[keyProp.name];
        });
        return keyValues;
    }
    prepareKeys(keyValues) {
        if (Object.keys(keyValues).length === 1 && Object.keys(keyValues)[0] === '') {
            // "default" key - .../Entity('abc')
            const keyName = this.entityTypeDefinition.keys[0].name;
            return { [keyName]: keyValues[''] };
        }
        else {
            // named keys - .../Entity(ID='abc')
            return { ...keyValues };
        }
    }
    performGET(keyValues, asArray, tenantId, odataRequest, dontClone = false) {
        var _a, _b, _c, _d, _e, _f;
        const currentMockData = this.getMockData(tenantId);
        if (keyValues && Object.keys(keyValues).length) {
            keyValues = this.prepareKeys(keyValues);
            const data = currentMockData.fetchEntries(keyValues, odataRequest);
            if (!data || (Array.isArray(data) && data.length === 0 && !asArray)) {
                if (!currentMockData.hasEntries(odataRequest)) {
                    return currentMockData.getEmptyObject(odataRequest);
                }
                else {
                    return null;
                }
            }
            let outData = data;
            if (Array.isArray(outData) && !asArray) {
                outData = outData[0];
            }
            if (!dontClone) {
                outData = (0, lodash_clonedeep_1.default)(outData);
            }
            return outData;
        }
        if ((_e = (_d = (_c = (_b = (_a = this.entitySetDefinition) === null || _a === void 0 ? void 0 : _a.entityType) === null || _b === void 0 ? void 0 : _b.annotations) === null || _c === void 0 ? void 0 : _c.Common) === null || _d === void 0 ? void 0 : _d.ResultContext) === null || _e === void 0 ? void 0 : _e.valueOf()) {
            // Parametrized entityset, they cannot be requested directly
            throw new Error(JSON.stringify({ message: 'Parametrized entityset need to be queried with keys' }));
        }
        if (((_f = this.entitySetDefinition) === null || _f === void 0 ? void 0 : _f._type) === 'Singleton') {
            return currentMockData.getDefaultElement(odataRequest);
        }
        if (!asArray) {
            return (0, lodash_clonedeep_1.default)(currentMockData.getDefaultElement(odataRequest));
        }
        return currentMockData.getAllEntries(odataRequest, dontClone);
    }
    async performPOST(keyValues, postData, tenantId, odataRequest, _updateParent = false) {
        var _a;
        // Validate potentially missing keys
        keyValues = this.prepareKeys(keyValues);
        const currentMockData = this.getMockData(tenantId);
        Object.keys(keyValues).forEach((key) => {
            if (!postData[key]) {
                postData[key] = keyValues[key];
            }
        });
        this.entityTypeDefinition.keys.forEach((keyProp) => {
            if (postData[keyProp.name] === undefined || postData[keyProp.name].length === 0) {
                // Missing key
                if (keyProp.name === 'IsActiveEntity') {
                    postData['IsActiveEntity'] = false;
                }
                else {
                    postData[keyProp.name] = currentMockData.generateKey(keyProp);
                }
            }
        });
        let newObject = currentMockData.getEmptyObject(odataRequest);
        for (const navigationProperty of this.entityTypeDefinition.navigationProperties) {
            const navigationPropertyBindgOperator = `${navigationProperty.name}@odata.bind`;
            if (postData.hasOwnProperty(navigationPropertyBindgOperator)) {
                const reference = postData[navigationPropertyBindgOperator];
                if ((_a = this.entitySetDefinition) === null || _a === void 0 ? void 0 : _a.navigationPropertyBinding[navigationProperty.name]) {
                    const content = await this.dataAccess.getData(new odataRequest_1.default({
                        method: 'GET',
                        url: '/' + reference,
                        tenantId
                    }, this.dataAccess));
                    for (const referentialConstraint of navigationProperty.referentialConstraint) {
                        postData[referentialConstraint.sourceProperty] = content[referentialConstraint.targetProperty];
                    }
                }
                delete postData[navigationPropertyBindgOperator];
            }
        }
        newObject = Object.assign(newObject, postData);
        await currentMockData.addEntry(newObject, odataRequest);
        return newObject;
    }
    async performPATCH(keyValues, patchData, tenantId, odataRequest, _updateParent = false) {
        var _a;
        keyValues = this.prepareKeys(keyValues);
        const data = this.performGET(keyValues, false, tenantId, odataRequest);
        const currentMockData = this.getMockData(tenantId);
        const updatedData = Object.assign(data, patchData);
        for (const navigationProperty of this.entityTypeDefinition.navigationProperties) {
            const navigationPropertyBindgOperator = `${navigationProperty.name}@odata.bind`;
            if (patchData.hasOwnProperty(navigationPropertyBindgOperator)) {
                const reference = patchData[navigationPropertyBindgOperator];
                if (reference === null) {
                    for (const referentialConstraint of navigationProperty.referentialConstraint) {
                        delete updatedData[referentialConstraint.sourceProperty];
                    }
                }
                else if ((_a = this.entitySetDefinition) === null || _a === void 0 ? void 0 : _a.navigationPropertyBinding[navigationProperty.name]) {
                    const content = await this.dataAccess.getData(new odataRequest_1.default({
                        method: 'GET',
                        url: '/' + reference
                    }, this.dataAccess));
                    for (const referentialConstraint of navigationProperty.referentialConstraint) {
                        updatedData[referentialConstraint.sourceProperty] =
                            content[referentialConstraint.targetProperty];
                    }
                }
                delete updatedData[navigationPropertyBindgOperator];
            }
        }
        await currentMockData.onBeforeUpdateEntry(keyValues, updatedData, odataRequest);
        await currentMockData.updateEntry(keyValues, updatedData, patchData, odataRequest);
        await currentMockData.onAfterUpdateEntry(keyValues, updatedData, odataRequest);
        return updatedData;
    }
    async performDELETE(keyValues, tenantId, odataRequest, _updateParent = false) {
        const currentMockData = this.getMockData(tenantId);
        keyValues = this.prepareKeys(keyValues);
        const entryToRemove = currentMockData.fetchEntries(keyValues, odataRequest);
        let additionalEntriesToRemove = [];
        for (const aggregationElementName in this.entityTypeDefinition.annotations.Aggregation) {
            if (aggregationElementName.startsWith('RecursiveHierarchy')) {
                const recursiveHierarchy = this.entityTypeDefinition.annotations.Aggregation[aggregationElementName];
                const allData = currentMockData.getAllEntries(odataRequest, true);
                additionalEntriesToRemove = await currentMockData.getDescendants(allData, allData, entryToRemove, this.entityTypeDefinition, {
                    hierarchyRoot: '',
                    inputSetTransformations: [],
                    qualifier: recursiveHierarchy.qualifier,
                    propertyPath: '',
                    maximumDistance: -1,
                    keepStart: false
                }, odataRequest);
            }
        }
        await currentMockData.removeEntry(keyValues, odataRequest);
        if (additionalEntriesToRemove.length > 0) {
            for (const additionalEntriesToRemoveElement of additionalEntriesToRemove) {
                await this.performDELETE(this.getKeys(additionalEntriesToRemoveElement), tenantId, odataRequest, true);
            }
        }
    }
    async executeAction(actionDefinition, actionData, odataRequest, keys) {
        const currentMockData = this.getMockData(odataRequest.tenantId);
        keys = this.prepareKeys(keys);
        actionData = await currentMockData.onBeforeAction(actionDefinition, actionData, keys, odataRequest);
        let responseObject = await currentMockData.executeAction(actionDefinition, actionData, keys, odataRequest);
        responseObject = await currentMockData.onAfterAction(actionDefinition, actionData, keys, responseObject, odataRequest);
        return responseObject;
    }
    async getParentEntityInterface(tenantId) {
        const parentEntitySetName = this.dataAccess.getMetadata().getParentEntitySetName(this.entitySetDefinition);
        return this.getEntityInterface(parentEntitySetName, tenantId);
    }
    async getEntityInterface(entitySet, tenantId) {
        const mockEntitySet = await this.dataAccess.getMockEntitySet(entitySet);
        return mockEntitySet === null || mockEntitySet === void 0 ? void 0 : mockEntitySet.getMockData(tenantId);
    }
}
exports.MockDataEntitySet = MockDataEntitySet;
//# sourceMappingURL=entitySet.js.map