"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileBasedMockData = void 0;
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const common_1 = require("../data/common");
function performSimpleComparison(operator, mockValue, targetLiteral) {
    let isValid = true;
    switch (operator) {
        case 'gt':
            isValid = mockValue > targetLiteral;
            break;
        case 'ge':
            isValid = mockValue >= targetLiteral;
            break;
        case 'lt':
            isValid = mockValue < targetLiteral;
            break;
        case 'le':
            isValid = mockValue <= targetLiteral;
            break;
        case 'ne':
            isValid = mockValue !== targetLiteral;
            break;
        case 'eq':
        default:
            isValid = mockValue === targetLiteral;
            break;
    }
    return isValid;
}
function getSourceReference(aggregationAnnotation) {
    var _a;
    const parentNavigationProperty = aggregationAnnotation.ParentNavigationProperty;
    const referentialConstraint = (_a = parentNavigationProperty.$target) === null || _a === void 0 ? void 0 : _a.referentialConstraint[0];
    if (!parentNavigationProperty.$target || !referentialConstraint) {
        throw new Error(`Unknown ParentNavigationProperty: '${parentNavigationProperty.value}'`);
    }
    return referentialConstraint.sourceProperty;
}
function getNodeProperty(aggregationAnnotation) {
    const nodeProperty = aggregationAnnotation.NodeProperty;
    if (!nodeProperty.$target) {
        throw new Error(`Unknown NodeProperty: '${nodeProperty.value}'`);
    }
    return nodeProperty.$target.name;
}
class FileBasedMockData {
    constructor(mockData, entityType, mockDataEntitySet, contextId) {
        this._hierarchyTree = {};
        this._entityType = entityType;
        this._contextId = contextId;
        this._mockDataEntitySet = mockDataEntitySet;
        if (mockData.length === 0 && mockData.__generateMockData) {
            this._mockData = this.generateMockData();
        }
        else {
            this._mockData = (0, lodash_clonedeep_1.default)(mockData);
            if (this._mockData.forEach) {
                this._mockData.forEach((mockLine) => {
                    // We need to ensure that complex types are at least partially created
                    this.validateProperties(mockLine, this._entityType.entityProperties);
                });
            }
            this.cleanupHierarchies();
        }
    }
    validateProperties(mockEntry, properties) {
        properties.forEach((prop) => {
            if (!prop.nullable && !mockEntry.hasOwnProperty(prop.name)) {
                mockEntry[prop.name] = this.getDefaultValueFromType(prop.type, prop.targetType, prop.defaultValue);
            }
            else if (mockEntry.hasOwnProperty(prop.name) && (0, annotation_converter_1.isComplexTypeDefinition)(prop.targetType)) {
                // If the property is defined from a complex type we should validate the property of the complex type
                this.validateProperties(mockEntry[prop.name], prop.targetType.properties);
            }
        });
    }
    cleanupHierarchies() {
        var _a, _b;
        const allAggregations = (_b = (_a = this._entityType.annotations) === null || _a === void 0 ? void 0 : _a.Aggregation) !== null && _b !== void 0 ? _b : {};
        Object.keys(allAggregations)
            .filter((aggregationName) => aggregationName.startsWith('RecursiveHierarchy'))
            .forEach((aggregationName) => {
            const aggregationDefinition = allAggregations[aggregationName];
            const hierarchyDefinition = this.getHierarchyDefinition(aggregationDefinition.qualifier);
            if (this._mockData.forEach) {
                this._mockData.forEach((mockLine) => {
                    this.cleanupHierarchyData(mockLine, hierarchyDefinition);
                });
            }
        });
    }
    cleanupHierarchyData(mockEntry, hierarchyDefinition) {
        if (hierarchyDefinition.matchedProperty) {
            delete mockEntry[hierarchyDefinition.matchedProperty];
        }
        if (hierarchyDefinition.matchedDescendantCountProperty) {
            delete mockEntry[hierarchyDefinition.matchedDescendantCountProperty];
        }
        if (hierarchyDefinition.limitedDescendantCountProperty) {
            delete mockEntry[hierarchyDefinition.limitedDescendantCountProperty];
        }
        if (hierarchyDefinition.drillStateProperty) {
            delete mockEntry[hierarchyDefinition.drillStateProperty];
        }
        if (hierarchyDefinition.distanceFromRootProperty) {
            delete mockEntry[hierarchyDefinition.distanceFromRootProperty];
        }
    }
    async addEntry(mockEntry, _odataRequest) {
        this._mockData.push(mockEntry);
    }
    async updateEntry(keyValues, updatedData, _patchData, _odataRequest) {
        const dataIndex = this.getDataIndex(keyValues, _odataRequest);
        this._mockData[dataIndex] = updatedData;
    }
    fetchEntries(keyValues, _odataRequest) {
        const keys = this._entityType.keys;
        return this._mockData.filter((mockData) => {
            return Object.keys(keyValues).every(this.checkKeyValues(mockData, keyValues, keys, _odataRequest));
        });
    }
    hasEntry(keyValues, _odataRequest) {
        return this.getDataIndex(keyValues, _odataRequest) !== -1;
    }
    hasEntries(_odataRequest) {
        return this._mockData.length > 0;
    }
    getAllEntries(_odataRequest, dontClone = false) {
        if (dontClone) {
            return this._mockData;
        }
        return (0, lodash_clonedeep_1.default)(this._mockData);
    }
    getDataIndex(keyValues, _odataRequest) {
        const keys = this._entityType.keys;
        return this._mockData.findIndex((mockData) => {
            return Object.keys(keyValues).every(this.checkKeyValues(mockData, keyValues, keys, _odataRequest));
        });
    }
    checkKeyValues(mockData, keyValues, keys, _odataRequest) {
        return (keyName) => {
            return this._mockDataEntitySet.checkKeyValue(mockData, keyValues, keyName, keys.find((keyProp) => keyProp.name === keyName));
        };
    }
    async removeEntry(keyValues, _odataRequest) {
        const dataIndex = this.getDataIndex(keyValues, _odataRequest);
        if (dataIndex !== -1) {
            this._mockData.splice(dataIndex, 1);
        }
    }
    getDefaultValueFromType(type, complexType, defaultValue) {
        if (complexType) {
            if (complexType._type === 'ComplexType') {
                const outData = {};
                complexType.properties.forEach((subProp) => {
                    outData[subProp.name] = this.getDefaultValueFromType(subProp.type, subProp.targetType, subProp.defaultValue);
                });
                return outData;
            }
            else if (complexType._type === 'TypeDefinition') {
                type = complexType.underlyingType;
            }
        }
        if (defaultValue !== undefined) {
            return defaultValue;
        }
        switch (type) {
            case 'Edm.Int16':
            case 'Edm.Byte':
            case 'Edm.Int32':
            case 'Edm.Int64':
            case 'Edm.Decimal':
                return 0;
            case 'Edm.Boolean':
                return false;
            case 'Edm.DateTimeOffset': {
                const date = new Date();
                return this._mockDataEntitySet.isV4() ? date.toISOString() : '/Date(' + date.getTime() + '+0000)/';
            }
            case 'Edm.Date':
            case 'Edm.DateTime': {
                const date = new Date();
                const dateOut = date.getUTCFullYear() +
                    '-' +
                    ('0' + (date.getUTCMonth() + 1)).slice(-2) +
                    '-' +
                    ('0' + date.getUTCDate()).slice(-2);
                return this._mockDataEntitySet.isV4() ? dateOut : '/Date(' + date.getTime() + '+0000)/';
            }
            case 'Edm.Time':
            case 'Time': {
                const date = new Date();
                // ODataModel expects ISO8601 duration format
                return 'PT' + date.getHours() + 'H' + date.getMinutes() + 'M' + date.getSeconds() + 'S';
            }
            default:
                return '';
        }
    }
    getRandomValueFromType(type, complexType, propertyName, lineIndex) {
        if (complexType) {
            const outData = {};
            if (complexType._type === 'ComplexType') {
                complexType.properties.forEach((subProp) => {
                    outData[subProp.name] = this.getRandomValueFromType(subProp.type, subProp.targetType, subProp.name, lineIndex);
                });
                return outData;
            }
            else if (complexType._type === 'TypeDefinition') {
                type = complexType.underlyingType;
            }
        }
        switch (type) {
            case 'Edm.Int16':
            case 'Edm.Int32':
            case 'Edm.Int64':
                return Math.floor(Math.random() * 10000);
            case 'Edm.String':
                return `${propertyName}_${lineIndex}`;
            case 'Edm.Boolean':
                return Math.random() < 0.5;
            case 'Edm.Byte':
                return Math.floor(Math.random() * 10);
            case 'Edm.Decimal':
                return Math.floor(Math.random() * 100000) / 100;
            case 'Edm.Guid':
                return (0, common_1.uuidv4)();
            case 'Edm.Date':
            case 'Edm.DateTime':
            case 'Edm.DateTimeOffset': {
                const date = new Date();
                date.setFullYear(2000 + Math.floor(Math.random() * 22));
                date.setDate(Math.floor(Math.random() * 30));
                date.setMonth(Math.floor(Math.random() * 12));
                date.setMilliseconds(0);
                if (type === 'Edm.Date') {
                    const dateOut = date.getUTCFullYear() +
                        '-' +
                        ('0' + (date.getUTCMonth() + 1)).slice(-2) +
                        '-' +
                        ('0' + date.getUTCDate()).slice(-2);
                    return this._mockDataEntitySet.isV4() ? dateOut : '/Date(' + date.getTime() + '+0000)/';
                }
                else {
                    return this._mockDataEntitySet.isV4() ? date.toISOString() : '/Date(' + date.getTime() + '+0000)/';
                }
            }
            case 'Edm.Time':
            case 'Time':
                // ODataModel expects ISO8601 duration format
                return ('PT' +
                    Math.floor(Math.random() * 23) +
                    'H' +
                    Math.floor(Math.random() * 59) +
                    'M' +
                    Math.floor(Math.random() * 59) +
                    'S');
            case 'Edm.TimeOfDay':
            case 'Edm.Binary':
            default:
                return '';
        }
    }
    getEmptyObject(_odataRequest) {
        const outObj = {};
        this._entityType.entityProperties.forEach((property) => {
            outObj[property.name] = this.getDefaultValueFromType(property.type, property.targetType, property.defaultValue);
        });
        return outObj;
    }
    getDefaultElement(_odataRequest) {
        if (this._mockData && !Array.isArray(this._mockData)) {
            return this._mockData;
        }
        else if (this._mockData.length >= 1) {
            return (0, lodash_clonedeep_1.default)(this._mockData[0]);
        }
        else {
            return this.getEmptyObject(_odataRequest);
        }
    }
    generateKey(property, lineIndex, mockData = []) {
        const currentMockData = this._mockData || mockData;
        let highestIndex;
        switch (property.type) {
            case 'Edm.Int32':
                highestIndex = 0;
                currentMockData.forEach((mockLine) => {
                    const mockLineIndex = parseInt(mockLine[property.name], 10);
                    highestIndex = Math.max(highestIndex, mockLineIndex);
                });
                return highestIndex + 1;
            case 'Edm.Boolean':
                return Math.random() > 0.5;
            case 'Edm.Guid':
                return (0, common_1.uuidv4)();
            case 'Edm.String':
                if (lineIndex === undefined) {
                    lineIndex = currentMockData.length + 1;
                }
                return `${property.name}_${lineIndex}`;
            default:
                return (0, common_1.generateId)(12);
        }
    }
    generateMockDataLine(iIndex, mockData) {
        const outObj = {};
        this._entityType.entityProperties.forEach((property) => {
            if (property.isKey) {
                outObj[property.name] = this.generateKey(property, iIndex, mockData);
            }
            else {
                outObj[property.name] = this.getRandomValueFromType(property.type, property.targetType, property.name, iIndex);
            }
        });
        this._entityType.navigationProperties.forEach((navigationProperty) => {
            if (navigationProperty.containsTarget) {
                outObj[navigationProperty.name] = [];
            }
        });
        return outObj;
    }
    getParentEntityInterface() {
        return this._mockDataEntitySet.getParentEntityInterface(this._contextId);
    }
    getEntityInterface(entitySetName) {
        return this._mockDataEntitySet.getEntityInterface(entitySetName, this._contextId);
    }
    generateMockData() {
        const mockData = [];
        for (let i = 0; i < 150; i++) {
            mockData.push(this.generateMockDataLine(i, mockData));
        }
        return mockData;
    }
    /**
     * Allow to modify the action data beforehand.
     *
     * @param _actionDefinition
     * @param actionData
     * @param _keys
     * @param _odataRequest
     */
    async onBeforeAction(_actionDefinition, actionData, _keys, _odataRequest) {
        return actionData;
    }
    /**
     * Do something with the action.
     *
     * @param _actionDefinition
     * @param actionData
     * @param _keys
     * @param _odataRequest
     */
    async executeAction(_actionDefinition, actionData, _keys, _odataRequest) {
        return actionData;
    }
    /**
     * Allow to modify the response data.
     *
     * @param _actionDefinition
     * @param _actionData
     * @param _keys
     * @param responseData
     * @param _odataRequest
     */
    async onAfterAction(_actionDefinition, _actionData, _keys, responseData, _odataRequest) {
        return responseData;
    }
    //eslint-disable-next-line
    async onAfterUpdateEntry(_keyValues, _updatedData, _odataRequest) {
        // DO Nothing
    }
    //eslint-disable-next-line
    async onBeforeUpdateEntry(_keyValues, _updatedData, _odataRequest) {
        // DO Nothing
    }
    //eslint-disable-next-line
    hasCustomAggregate(_customAggregateName, _odataRequest) {
        return false;
    }
    //eslint-disable-next-line
    performCustomAggregate(_customAggregateName, _dataToAggregate, _odataRequest) {
        // DO Nothing
    }
    checkSearchQuery(mockValue, searchQuery, _odataRequest) {
        return mockValue === null || mockValue === void 0 ? void 0 : mockValue.toString().includes(searchQuery);
    }
    checkFilterValue(comparisonType, mockValue, literal, operator, _odataRequest) {
        let isValid = true;
        switch (comparisonType) {
            case 'Edm.Boolean':
                isValid = !!mockValue === (literal === 'true');
                break;
            case 'Edm.Byte':
            case 'Edm.Int16':
            case 'Edm.Int32':
            case 'Edm.Int64': {
                const intTestValue = parseInt(literal, 10);
                isValid = performSimpleComparison(operator, mockValue, intTestValue);
                break;
            }
            case 'Edm.Decimal': {
                const decimalTestValue = parseFloat(literal);
                isValid = performSimpleComparison(operator, mockValue, decimalTestValue);
                break;
            }
            case 'Edm.Date':
            case 'Edm.Time':
            case 'Edm.DateTime':
            case 'Edm.DateTimeOffset':
                let targetDateLiteral = literal;
                if (literal && literal.startsWith("datetime'")) {
                    targetDateLiteral = literal.substring(9, literal.length - 1);
                }
                const testValue = new Date(targetDateLiteral).getTime();
                const mockValueDate = new Date(mockValue).getTime();
                isValid = performSimpleComparison(operator, mockValueDate, testValue);
                break;
            case 'Edm.String':
            case 'Edm.Guid':
            default:
                let targetLiteral = literal;
                if (literal && literal.startsWith("guid'")) {
                    targetLiteral = literal.substring(5, literal.length - 1);
                }
                else if (literal && literal.startsWith("'")) {
                    targetLiteral = literal.substring(1, literal.length - 1);
                }
                isValid = performSimpleComparison(operator, mockValue === null || mockValue === void 0 ? void 0 : mockValue.toString(), targetLiteral);
                break;
        }
        return isValid;
    }
    async getReferentialConstraints(_navigationProperty) {
        return undefined;
    }
    buildTree(hierarchyNode, allItems, idNode, parentIdentifier, depth = 0, parentNode) {
        const id = hierarchyNode[idNode];
        const children = allItems[id];
        const resultingChildren = [];
        if (children) {
            for (const child of children) {
                //if (child.$inResultSet === true || child.$inResultSet === undefined) {
                resultingChildren.push(this.buildTree(child, allItems, idNode, parentIdentifier, depth + 1, hierarchyNode));
                //}
            }
        }
        hierarchyNode.$parent = parentNode;
        hierarchyNode.$children = resultingChildren;
        hierarchyNode.$rootDistance = depth;
        return hierarchyNode;
    }
    buildHierarchyTree(hierarchyQualifier, inputSet, hierarchyDefinition) {
        //if (!this._hierarchyTree[hierarchyQualifier]) {
        const itemPerParents = {};
        inputSet.forEach((item) => {
            if (!itemPerParents[item[hierarchyDefinition.sourceReference]]) {
                itemPerParents[item[hierarchyDefinition.sourceReference]] = [];
            }
            itemPerParents[item[hierarchyDefinition.sourceReference]].push(item);
        });
        this._hierarchyTree[hierarchyQualifier] = itemPerParents;
        return this._hierarchyTree[hierarchyQualifier];
    }
    flattenTree(currentNode, outItems, nodeProperty, hierarchyDefinition, depth, toExpand = [], toCollapse = [], toShow = [], toShowAncestors = [], forceExpand = false) {
        var _a, _b;
        let descendantCount = 0;
        const shouldShowAncestor = toShowAncestors.includes(currentNode[nodeProperty]);
        if (currentNode && (depth < 0 || depth > 0 || forceExpand || shouldShowAncestor)) {
            const shouldExpand = toExpand.includes(currentNode[nodeProperty]);
            if (shouldExpand) {
                depth++;
            }
            const shouldShow = toShow.includes(currentNode[nodeProperty]);
            if (shouldShowAncestor && !shouldExpand) {
                forceExpand = true;
            }
            if (shouldShow && !shouldShowAncestor) {
                depth = 1;
            }
            const shouldCollapse = toCollapse.includes(currentNode[nodeProperty]);
            if (shouldCollapse) {
                depth = 1;
            }
            const isLastLevel = depth === 1;
            const isPastLastLevel = depth === 0;
            let wasAdded = false;
            if (!outItems.includes(currentNode) &&
                (!isPastLastLevel || !forceExpand || shouldShow || shouldShowAncestor)) {
                wasAdded = true;
                outItems.push(currentNode);
            }
            if (hierarchyDefinition.distanceFromRootProperty) {
                currentNode[hierarchyDefinition.distanceFromRootProperty] = currentNode.$rootDistance;
            }
            if (hierarchyDefinition.drillStateProperty) {
                if (((_a = currentNode.$children) === null || _a === void 0 ? void 0 : _a.length) === 0) {
                    currentNode[hierarchyDefinition.drillStateProperty] = 'leaf';
                }
                else if (isLastLevel && !shouldShowAncestor) {
                    currentNode[hierarchyDefinition.drillStateProperty] = 'collapsed';
                }
                else {
                    currentNode[hierarchyDefinition.drillStateProperty] = 'expanded';
                }
            }
            const children = (_b = currentNode.$children) !== null && _b !== void 0 ? _b : [];
            children.forEach((child) => {
                descendantCount += this.flattenTree(child, outItems, nodeProperty, hierarchyDefinition, depth - 1, toExpand, toCollapse, toShow, toShowAncestors, forceExpand);
            });
            if (hierarchyDefinition.limitedDescendantCountProperty) {
                currentNode[hierarchyDefinition.limitedDescendantCountProperty] =
                    isLastLevel && !shouldShowAncestor ? 0 : descendantCount;
            }
            if (currentNode.$inResultSet && wasAdded) {
                descendantCount++;
            }
            return descendantCount;
        }
        return descendantCount;
    }
    getAncestorsOfNode(currentNode, outItems, nodeProperty, hierarchyDefinition, depth, matchedChildrenCount, matchedProperties) {
        var _a, _b;
        let descendantCount = 0;
        if (currentNode && (depth < 0 || depth > 0)) {
            const isLastLevel = depth === 1;
            if (outItems.includes(currentNode)) {
                if (hierarchyDefinition.matchedDescendantCountProperty) {
                    currentNode[hierarchyDefinition.matchedDescendantCountProperty] += matchedChildrenCount;
                }
            }
            else {
                outItems.push(currentNode);
                if (hierarchyDefinition.matchedDescendantCountProperty) {
                    currentNode[hierarchyDefinition.matchedDescendantCountProperty] = matchedChildrenCount;
                }
                if (hierarchyDefinition.matchedProperty) {
                    currentNode[hierarchyDefinition.matchedProperty] = !!matchedProperties.find((prop) => prop[nodeProperty] === currentNode[nodeProperty]);
                    if (currentNode[hierarchyDefinition.matchedProperty]) {
                        matchedChildrenCount++;
                    }
                }
                if (hierarchyDefinition.distanceFromRootProperty) {
                    currentNode[hierarchyDefinition.distanceFromRootProperty] = currentNode.$rootDistance;
                }
                if (hierarchyDefinition.drillStateProperty) {
                    const includedChildrenCount = (_b = (_a = currentNode.$children) === null || _a === void 0 ? void 0 : _a.filter((child) => child.$inResultSet).length) !== null && _b !== void 0 ? _b : 0;
                    if (isLastLevel && includedChildrenCount === 0) {
                        currentNode[hierarchyDefinition.drillStateProperty] = 'leaf';
                    }
                    else if (isLastLevel) {
                        currentNode[hierarchyDefinition.drillStateProperty] = 'collapsed';
                    }
                    else {
                        currentNode[hierarchyDefinition.drillStateProperty] = 'expanded';
                    }
                }
            }
            if (currentNode.$parent) {
                this.getAncestorsOfNode(currentNode.$parent, outItems, nodeProperty, hierarchyDefinition, depth - 1, matchedChildrenCount, matchedProperties);
            }
            descendantCount++; // also include yourself
            return descendantCount;
        }
        return descendantCount;
    }
    async getTopLevels(data, _parameters, _odataRequest) {
        var _a, _b, _c, _d, _e, _f;
        const hierarchyQualifier = _parameters.HierarchyQualifier.substring(1, _parameters.HierarchyQualifier.length - 1);
        const outItems = [];
        const aggregationAnnotation = (_b = (_a = this._entityType.annotations) === null || _a === void 0 ? void 0 : _a.Aggregation) === null || _b === void 0 ? void 0 : _b[`RecursiveHierarchy#${hierarchyQualifier}`];
        if (aggregationAnnotation) {
            const nodeProperty = getNodeProperty(aggregationAnnotation);
            let adjustedData = data.map((adjustedRowData) => {
                const item = this._mockData.find((dataItem) => dataItem[nodeProperty] === adjustedRowData[nodeProperty]);
                return { ...item, ...adjustedRowData, ...{ $inResultSet: true } };
            });
            const restOfData = this._mockData
                .filter((item) => {
                return !data.find((dataItem) => dataItem[nodeProperty] === item[nodeProperty]);
            })
                .map((item) => {
                return { ...item, ...{ $inResultSet: false } };
            });
            adjustedData = adjustedData.concat(restOfData);
            const hierarchyDefinition = this.getHierarchyDefinition(hierarchyQualifier);
            const hierarchyNodes = this.buildHierarchyTree(hierarchyQualifier, adjustedData, hierarchyDefinition);
            const sourceReference = getSourceReference(aggregationAnnotation);
            // TODO Considering the input set the top level node is not necessarely the root node
            const allRootNodes = adjustedData.filter((node) => {
                const parent = adjustedData.find((parent) => parent[nodeProperty] === node[sourceReference]);
                return !parent || !parent.$inResultSet;
            });
            allRootNodes.sort((a) => {
                if (a.$rootDistance === undefined) {
                    return -1;
                }
                return 1;
            });
            const depth = parseInt(_parameters.Levels, 10);
            const toExpand = (_d = (_c = _parameters.Expand) === null || _c === void 0 ? void 0 : _c.map((expand) => expand.substring(1, expand.length - 1))) !== null && _d !== void 0 ? _d : [];
            const toShow = (_f = (_e = _parameters.Show) === null || _e === void 0 ? void 0 : _e.map((collapse) => collapse.substring(1, collapse.length - 1))) !== null && _f !== void 0 ? _f : [];
            const toShowAncestors = [];
            for (const nodeId of toShow) {
                const node = this._mockData.find((node) => node[nodeProperty] === nodeId);
                if (node) {
                    const toShowAncestorsDef = await this.getAncestors(this._mockData, this._mockData, [node], this._entityType, {
                        hierarchyRoot: '',
                        qualifier: hierarchyQualifier,
                        propertyPath: '',
                        maximumDistance: -1,
                        keepStart: false,
                        inputSetTransformations: []
                    }, _odataRequest);
                    toShowAncestorsDef.forEach((ancestor) => {
                        toShowAncestors.push(ancestor[nodeProperty]);
                    });
                }
            }
            allRootNodes.forEach((rootNode) => {
                var _a;
                const hierarchy = this.buildTree(rootNode, hierarchyNodes, nodeProperty, sourceReference, 0, undefined);
                this.flattenTree(hierarchy, outItems, nodeProperty, hierarchyDefinition, depth, toExpand, (_a = _parameters.Collapse) === null || _a === void 0 ? void 0 : _a.map((collapse) => collapse.substring(1, collapse.length - 1)), toShow, toShowAncestors);
            });
            let outData = [];
            outItems.forEach((item) => {
                const subTreeData = data.find((dataItem) => dataItem[nodeProperty] === item[nodeProperty]);
                if (subTreeData) {
                    if (hierarchyDefinition.matchedDescendantCountProperty &&
                        hierarchyDefinition.drillStateProperty &&
                        item[hierarchyDefinition.matchedDescendantCountProperty] === 0) {
                        item[hierarchyDefinition.drillStateProperty] = 'leaf';
                    }
                    outData.push({ ...subTreeData, ...item });
                }
                else if (toShow.includes(item[nodeProperty]) || toShowAncestors.includes(item[nodeProperty])) {
                    outData.push(item);
                }
            });
            // restrict tree data with skiplocation && skipcontext
            if (_odataRequest.skipLocation) {
                let skipLocation = _odataRequest.skipLocation.split('(')[1].split(')')[0];
                skipLocation = skipLocation.substring(1, skipLocation.length - 1);
                const skipLocationIndex = outData.findIndex((item) => item[nodeProperty] === skipLocation);
                if (skipLocationIndex >= _odataRequest.skipContext) {
                    outData = outData.slice(skipLocationIndex - _odataRequest.skipContext);
                    _odataRequest.addResponseAnnotation('@com.sap.vocabularies.Common.v1.skip', skipLocationIndex - _odataRequest.skipContext);
                }
            }
            return outData;
        }
        return outItems;
    }
    async getDescendants(inputSet, lastFilterTransformationResult, hierarchyFilter, entityType, _parameters, _odataRequest) {
        var _a, _b;
        const aggregationAnnotation = (_b = (_a = this._entityType.annotations) === null || _a === void 0 ? void 0 : _a.Aggregation) === null || _b === void 0 ? void 0 : _b[`RecursiveHierarchy#${_parameters.qualifier}`];
        const hierarchyDefinition = this.getHierarchyDefinition(_parameters.qualifier);
        if (aggregationAnnotation) {
            const nodeProperty = getNodeProperty(aggregationAnnotation);
            const adjustedData = this._mockData.map((item) => {
                const adjustedRowData = hierarchyFilter.find((dataItem) => dataItem[nodeProperty] === item[nodeProperty]);
                if (adjustedRowData) {
                    return { ...item, ...adjustedRowData, ...{ $inResultSet: true } };
                }
                else {
                    return { ...item, ...{ $inResultSet: false } };
                }
            });
            const hierarchyNodes = this.buildHierarchyTree(_parameters.qualifier, adjustedData, hierarchyDefinition);
            const sourceReference = getSourceReference(aggregationAnnotation);
            const rootNodes = hierarchyNodes[''];
            rootNodes.forEach((rootNode) => {
                this.buildTree(rootNode, hierarchyNodes, nodeProperty, sourceReference, 0, undefined);
            });
            const subTrees = [];
            hierarchyFilter.forEach((item) => {
                var _a;
                const parentNodeChildren = hierarchyNodes[item[sourceReference]];
                if (parentNodeChildren) {
                    const currentNode = parentNodeChildren.find((node) => node[nodeProperty] === item[nodeProperty]);
                    if (_parameters.keepStart) {
                        if (hierarchyDefinition.matchedProperty) {
                            // TODO compare with lastFilterTransformationResult
                            currentNode[hierarchyDefinition.matchedProperty] = true;
                        }
                        subTrees.push(currentNode);
                    }
                    (_a = currentNode.$children) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
                        this.flattenTree(child, subTrees, nodeProperty, hierarchyDefinition, _parameters.maximumDistance);
                    });
                }
            });
            const outData = [];
            inputSet.forEach((item) => {
                const subTreeData = subTrees.find((dataItem) => dataItem[nodeProperty] === item[nodeProperty]);
                if (subTreeData) {
                    if (hierarchyDefinition.matchedDescendantCountProperty &&
                        hierarchyDefinition.drillStateProperty &&
                        item[hierarchyDefinition.matchedDescendantCountProperty] === 0) {
                        subTreeData[hierarchyDefinition.drillStateProperty] = 'leaf';
                    }
                    outData.push({ ...item, ...subTreeData });
                }
            });
            return outData;
        }
        else {
            return [];
        }
    }
    getHierarchyDefinition(hierarchyQualifier) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const hierarchyAnnotation = (_b = (_a = this._entityType.annotations) === null || _a === void 0 ? void 0 : _a.Hierarchy) === null || _b === void 0 ? void 0 : _b[`RecursiveHierarchy#${hierarchyQualifier}`];
        const aggregationAnnotation = (_d = (_c = this._entityType.annotations) === null || _c === void 0 ? void 0 : _c.Aggregation) === null || _d === void 0 ? void 0 : _d[`RecursiveHierarchy#${hierarchyQualifier}`];
        return {
            distanceFromRootProperty: (_e = hierarchyAnnotation === null || hierarchyAnnotation === void 0 ? void 0 : hierarchyAnnotation.DistanceFromRootProperty) === null || _e === void 0 ? void 0 : _e.$target.name,
            drillStateProperty: (_f = hierarchyAnnotation === null || hierarchyAnnotation === void 0 ? void 0 : hierarchyAnnotation.DrillStateProperty) === null || _f === void 0 ? void 0 : _f.$target.name,
            limitedDescendantCountProperty: (_g = hierarchyAnnotation === null || hierarchyAnnotation === void 0 ? void 0 : hierarchyAnnotation.LimitedDescendantCountProperty) === null || _g === void 0 ? void 0 : _g.$target.name,
            matchedDescendantCountProperty: (_h = hierarchyAnnotation === null || hierarchyAnnotation === void 0 ? void 0 : hierarchyAnnotation.MatchedDescendantCountProperty) === null || _h === void 0 ? void 0 : _h.$target.name,
            matchedProperty: (_j = hierarchyAnnotation === null || hierarchyAnnotation === void 0 ? void 0 : hierarchyAnnotation.MatchedProperty) === null || _j === void 0 ? void 0 : _j.$target.name,
            sourceReference: getSourceReference(aggregationAnnotation)
        };
    }
    async getAncestors(inputSet, lastFilterTransformationResult, limitedHierarchy, entityType, _parameters, _odataRequest) {
        var _a, _b;
        const aggregationAnnotation = (_b = (_a = this._entityType.annotations) === null || _a === void 0 ? void 0 : _a.Aggregation) === null || _b === void 0 ? void 0 : _b[`RecursiveHierarchy#${_parameters.qualifier}`];
        const hierarchyDefinition = this.getHierarchyDefinition(_parameters.qualifier);
        if (aggregationAnnotation) {
            const nodeProperty = getNodeProperty(aggregationAnnotation);
            const sourceReference = getSourceReference(aggregationAnnotation);
            const adjustedData = this._mockData.map((item) => {
                const adjustedRowData = limitedHierarchy.find((dataItem) => dataItem[nodeProperty] === item[nodeProperty]);
                if (adjustedRowData) {
                    return { ...item, ...adjustedRowData, ...{ $inResultSet: true } };
                }
                else {
                    return { ...item, ...{ $inResultSet: false } };
                }
            });
            const hierarchyNodes = this.buildHierarchyTree(_parameters.qualifier, adjustedData, hierarchyDefinition);
            const rootNodes = hierarchyNodes[''];
            rootNodes.forEach((rootNode) => {
                this.buildTree(rootNode, hierarchyNodes, nodeProperty, sourceReference, 0, undefined);
            });
            const ancestors = [];
            limitedHierarchy.forEach((item) => {
                const parentNodeChildren = hierarchyNodes[item[sourceReference]];
                const currentNode = parentNodeChildren.find((node) => node[nodeProperty] === item[nodeProperty]);
                if (_parameters.keepStart) {
                    this.getAncestorsOfNode(currentNode, ancestors, nodeProperty, hierarchyDefinition, _parameters.maximumDistance - 1, 0, lastFilterTransformationResult);
                }
                else if (currentNode && currentNode.$parent) {
                    this.getAncestorsOfNode(currentNode.$parent, ancestors, nodeProperty, hierarchyDefinition, _parameters.maximumDistance - 1, 1, lastFilterTransformationResult);
                }
            });
            const outData = [];
            inputSet.forEach((item) => {
                const subTreeData = ancestors.find((dataItem) => dataItem[nodeProperty] === item[nodeProperty]);
                if (subTreeData) {
                    outData.push({ ...item, ...subTreeData });
                }
            });
            return outData;
        }
        else {
            return [];
        }
    }
}
exports.FileBasedMockData = FileBasedMockData;
//# sourceMappingURL=fileBasedMockData.js.map