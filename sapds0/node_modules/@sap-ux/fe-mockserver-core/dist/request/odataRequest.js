"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const balanced_match_1 = __importDefault(require("balanced-match"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const query_string_1 = require("query-string");
const url_1 = require("url");
const common_1 = require("../data/common");
const applyParser_1 = require("./applyParser");
const filterParser_1 = require("./filterParser");
const searchParser_1 = require("./searchParser");
class ODataRequest {
    constructor(requestContent, dataAccess) {
        var _a, _b, _c, _d;
        this.requestContent = requestContent;
        this.dataAccess = dataAccess;
        this.expandProperties = {};
        this.responseHeaders = {};
        this.globalResponseHeaders = {};
        this.statusCode = 200;
        this.responseAnnotations = {};
        this.messages = [];
        const parsedUrl = new url_1.URL(`http://dummy${requestContent.url}`);
        this.tenantId = requestContent.tenantId || 'tenant-default';
        this.context = requestContent.url.split('?')[0].substring(1);
        this.dataAccess.log.info(`ODataRequest: ${requestContent.method} ${requestContent.url}`);
        if (this.tenantId) {
            this.addResponseHeader('sap-tenantid', this.tenantId);
        }
        this.isMinimalRepresentation = ((_a = requestContent.headers) === null || _a === void 0 ? void 0 : _a['prefer']) === 'return=minimal';
        this.isStrictMode = (_d = (_c = (_b = requestContent.headers) === null || _b === void 0 ? void 0 : _b['prefer']) === null || _c === void 0 ? void 0 : _c.includes('handling=strict')) !== null && _d !== void 0 ? _d : false;
        this.queryPath = this.parsePath(parsedUrl.pathname.substring(1));
        this.parseParameters(parsedUrl.searchParams);
    }
    parseParameters(searchParams) {
        this.allParams = searchParams;
        this.searchQuery = (0, searchParser_1.parseSearch)(searchParams.get('$search'));
        this.orderBy = this.parseOrderBy(searchParams.get('$orderby'));
        this.startIndex = parseInt(searchParams.get('$skip') || '', 10);
        this.skipLocation = searchParams.get('sap-skiplocation');
        this.skipContext = parseInt(searchParams.get('sap-skipcontext') || '', 10);
        if (isNaN(this.startIndex)) {
            this.startIndex = 0;
        }
        this.maxElements = parseInt(searchParams.get('$top') || Number.POSITIVE_INFINITY.toString(), 10);
        if (isNaN(this.maxElements)) {
            this.maxElements = Number.POSITIVE_INFINITY;
        }
        this.applyDefinition = (0, applyParser_1.parseApply)(searchParams.get('$apply'));
        this.filterDefinition = (0, filterParser_1.parseFilter)(searchParams.get('$filter'));
        this.countRequested = searchParams.has('$count');
        this.isCountQuery = this.context.endsWith('$count');
        const selectParams = searchParams.get('$select');
        if (selectParams) {
            this.selectedProperties = {};
            const props = selectParams.split(',');
            props.forEach((property) => {
                if (property.length > 0) {
                    this.selectedProperties[property.split('/')[0]] = true;
                }
            });
        }
        else {
            this.selectedProperties = { '*': true };
        }
        const expandParams = searchParams.get('$expand');
        if (expandParams) {
            const expandParameters = this.parseExpand(expandParams);
            this.expandProperties = expandParameters.expand;
            this.selectedProperties = Object.assign(this.selectedProperties, expandParameters.properties || {});
        }
        if (this.filterDefinition) {
            this.addExpandForFilters(this.filterDefinition); // implicitly expand the properties used in filters
        }
        if (this.applyDefinition) {
            const additionalSelectProperty = {};
            this.applyDefinition.forEach((apply) => {
                this._addSelectedPropertiesForApplyExpression(apply, additionalSelectProperty);
            });
            this.selectedProperties = Object.assign(this.selectedProperties, additionalSelectProperty);
        }
    }
    _addSelectedPropertiesForApplyExpression(applyTransformation, additionalSelectProperty) {
        switch (applyTransformation.type) {
            case 'groupBy':
                applyTransformation.groupBy.forEach((groupByProperty) => {
                    additionalSelectProperty[groupByProperty] = true;
                });
                applyTransformation.subTransformations.forEach((subTransformation) => {
                    this._addSelectedPropertiesForApplyExpression(subTransformation, additionalSelectProperty);
                });
                break;
            case 'filter':
                this.addExpandForFilters(applyTransformation.filterExpr);
                break;
            case 'orderBy':
                applyTransformation.orderBy.forEach((orderByProperty) => {
                    additionalSelectProperty[orderByProperty.name] = true;
                });
                break;
            case 'aggregates':
                applyTransformation.aggregateDef.forEach((aggregateSourceProp) => {
                    additionalSelectProperty[aggregateSourceProp.sourceProperty] = true;
                });
                break;
            case 'ancestors':
            case 'descendants':
                applyTransformation.parameters.inputSetTransformations.forEach((subTransformation) => {
                    this._addSelectedPropertiesForApplyExpression(subTransformation, additionalSelectProperty);
                });
                break;
        }
    }
    /**
     * Split a list of properties that can contain sub-requests into an array.
     *
     * @param propertiesQuery OData properties request
     * @param delimiter Property delimiter
     * @returns an array of string with the properties
     */
    splitProperties(propertiesQuery, delimiter = ',') {
        const properties = [];
        let nestingDepth = 0, startIndex = 0, index = 0;
        for (; index < propertiesQuery.length; index++) {
            const char = propertiesQuery[index];
            if (char === delimiter && nestingDepth === 0) {
                // top-level delimiter â€” end of property
                if (index - startIndex > 0) {
                    properties.push(propertiesQuery.substring(startIndex, index));
                }
                startIndex = index + 1;
            }
            else if (char === '(') {
                nestingDepth++;
            }
            else if (char === ')') {
                nestingDepth--;
            }
        }
        if (index - startIndex > 0) {
            properties.push(propertiesQuery.substring(startIndex));
        }
        if (nestingDepth !== 0) {
            throw new common_1.ExecutionError(`Too many ${nestingDepth > 0 ? 'opening' : 'closing'} parentheses: ${propertiesQuery}`, 400, undefined, false);
        }
        return properties;
    }
    parseExpand(expandParameters) {
        const props = this.splitProperties(expandParameters);
        return props.reduce((reducer, property) => {
            var _a;
            if (this.dataAccess.getMetadata().getVersion() === '4.0') {
                const { pre: name, body: parameters } = (_a = (0, balanced_match_1.default)('(', ')', property)) !== null && _a !== void 0 ? _a : { pre: property, body: '' };
                const parameterSplit = this.splitProperties(parameters, ';');
                const queryPart = parameterSplit.reduce((acc, split) => Object.assign(acc, (0, query_string_1.parse)(split)), {});
                const expand = queryPart['$expand']
                    ? this.parseExpand(queryPart['$expand'])
                    : { expand: {}, properties: {} };
                const selectProperties = {};
                if (queryPart['$select']) {
                    // explicit $select
                    queryPart['$select']
                        .split(',')
                        .forEach((propertyName) => (selectProperties[propertyName] = true));
                }
                else {
                    selectProperties['*'] = true;
                }
                Object.keys(expand.properties).forEach((expandName) => {
                    selectProperties[expandName] = true;
                });
                reducer.expand[name] = {
                    expand: expand.expand,
                    properties: selectProperties
                };
                reducer.properties[name] = true;
                return reducer;
            }
            else {
                const propertySplit = property.split('/');
                const name = propertySplit[0];
                const expand = propertySplit[1]
                    ? this.parseExpand(propertySplit.slice(1).join('/'))
                    : { expand: {}, properties: {} };
                if (!reducer.expand[name]) {
                    reducer.expand[name] = {
                        expand: expand.expand,
                        properties: {
                            '*': true
                        }
                    };
                }
                else {
                    reducer.expand[name].expand = (0, lodash_merge_1.default)({}, reducer.expand[name].expand, expand.expand);
                }
                reducer.properties[name] = true;
                return reducer;
            }
        }, { expand: {}, properties: {} });
    }
    parseOrderBy(orderByParameters) {
        if (!orderByParameters) {
            return [];
        }
        const orderByParams = orderByParameters.split(',');
        const orderByDefinition = [];
        orderByParams.forEach((param) => {
            const [paramName, direction] = param.split(' ');
            const realDirection = ['asc', 'desc'].includes(direction)
                ? direction
                : 'asc';
            orderByDefinition.push({ name: paramName, direction: realDirection });
        });
        return orderByDefinition;
    }
    parsePath(path) {
        const pathSplit = path.split('/');
        return pathSplit.reduce((pathArr, pathPart) => {
            const keysStart = pathPart.indexOf('(');
            const keysEnd = pathPart.lastIndexOf(')');
            let entity;
            let keys = {};
            if (keysStart > -1) {
                entity = pathPart.substring(0, keysStart) + pathPart.substring(keysEnd + 1);
                const keysList = pathPart.substring(keysStart + 1, keysEnd).split(',');
                keys = {};
                keysList.forEach((keyValue) => {
                    const [key, value] = keyValue.split('=');
                    if (value) {
                        // .../Entity(ID='abc',IsActiveEntity=true) -> {ID: 'abc', IsActiveEntity: true}
                        keys[key] = ODataRequest.parseKeyValue(value);
                    }
                    else {
                        // .../Entity('abc') -> {'': 'abc'}
                        keys[''] = ODataRequest.parseKeyValue(key);
                    }
                });
            }
            else {
                entity = pathPart;
            }
            pathArr.push({ path: entity, keys: keys });
            return pathArr;
        }, []);
    }
    /**
     * Parse an OData key value.
     *
     * @param value The key value. Strings are expected to be surrounded by single quotes.
     * @returns The parsed value
     */
    static parseKeyValue(value) {
        value = decodeURIComponent(value);
        // string, e.g. "/Entity(key='abc')?
        if (value.startsWith("'") && value.endsWith("'")) {
            return decodeURIComponent(value.substring(1, value.length - 1));
        }
        // boolean, e.g. "/Entity(key=true)"?
        if (value === 'true' || value === 'false') {
            return value === 'true';
        }
        // number, e.g. "/Entity(key=123)"?
        const number = Number(value);
        if (!isNaN(number)) {
            return number;
        }
        // some other type, e.g. a UUID or a date - leave as string
        return value;
    }
    //
    // private parseApply(applyParameters: string | null): AggregateDefinition | undefined {
    //     if (!applyParameters) {
    //         return undefined;
    //     }
    //     const filterRegEx = /^filter\(([^)]+)\)\/(.*)$/;
    //     const filterMatches = applyParameters.match(filterRegEx);
    //     let groupByText = applyParameters;
    //     let filterParams;
    //     if (filterMatches) {
    //         const filterExpr = filterMatches[1];
    //         filterParams = parseFilter(filterExpr);
    //         groupByText = filterMatches[2];
    //     }
    //     const groupByRegEx = /^groupby\(\(([^)]+)\),([^)]+\))\)$/;
    //     const groupByMatches = groupByText.match(groupByRegEx);
    //     if (groupByMatches) {
    //         return {
    //             filter: filterParams,
    //             groupBy: groupByMatches[1].split(','),
    //             aggregates: this.parseAggregateDefinition(groupByMatches[2])
    //         };
    //     }
    // }
    // private parseAggregateDefinition(aggregationDefinition: string): AggregateProperty[] {
    //     const aggregateRegEx = /^aggregate\(([^)]+)\)$/;
    //     const aggregateMatches = aggregationDefinition.match(aggregateRegEx);
    //     if (aggregateMatches) {
    //         return aggregateMatches[1].split(',').map((aggregateMatch) => {
    //             const aggregateSplit = aggregateMatch.split(' ');
    //             const property = aggregateSplit[0];
    //             const operator = aggregateSplit[2];
    //             const targetName = aggregateSplit[4];
    //             return {
    //                 name: targetName || property,
    //                 operator,
    //                 sourceProperty: property
    //             };
    //         });
    //     } else {
    //         return [];
    //     }
    // }
    async handleRequest() {
        var _a;
        const contextId = (_a = this.requestContent.headers) === null || _a === void 0 ? void 0 : _a['sap-contextid'];
        if (contextId) {
            this.dataAccess.resetStickySessionTimeout(this, this.tenantId);
        }
        try {
            switch (this.requestContent.method) {
                case 'PATCH':
                case 'MERGE':
                case 'PUT': {
                    const updatedData = await this.dataAccess.updateData(this, this.requestContent.body);
                    this.setResponseData(updatedData);
                    break;
                }
                case 'DELETE':
                    await this.dataAccess.deleteData(this);
                    this.statusCode = 204;
                    break;
                case 'POST': {
                    const actionResponse = await this.dataAccess.performAction(this, this.requestContent.body);
                    if (actionResponse === null) {
                        this.setResponseData(await this.dataAccess.createData(this, this.requestContent.body));
                        this.statusCode = 201;
                    }
                    else if (actionResponse === undefined) {
                        this.setResponseData(actionResponse);
                        this.statusCode = 204;
                    }
                    else {
                        this.setResponseData(actionResponse);
                    }
                    break;
                }
                case 'HEAD':
                    break; // do nothing
                case 'GET':
                default: {
                    const actionResponse = await this.dataAccess.performAction(this);
                    if (actionResponse === null) {
                        const retrievedData = await this.dataAccess.getData(this);
                        if (retrievedData === undefined || retrievedData === null) {
                            this.statusCode = 404;
                            this.setResponseData('');
                        }
                        else {
                            this.setResponseData(retrievedData);
                        }
                    }
                    else {
                        this.setResponseData(actionResponse);
                    }
                    break;
                }
            }
        }
        catch (errorInfo) {
            const errorInformation = errorInfo;
            if (errorInformation.isCustomError) {
                if (errorInformation.messageData) {
                    if (errorInformation.isSAPMessage) {
                        this.addResponseHeader('sap-messages', JSON.stringify(errorInformation.messageData));
                    }
                    else {
                        this.addResponseHeader('content-type', 'application/json;odata.metadata=minimal;IEEE754Compatible=true');
                        this.setResponseData(JSON.stringify(errorInformation.messageData));
                    }
                }
                else {
                    this.addResponseHeader('content-type', 'text/plain');
                    this.setResponseData(errorInformation.message);
                }
                if (Object.keys(errorInformation.headers).length > 0) {
                    Object.keys(errorInformation.headers).forEach((headerName) => {
                        this.addResponseHeader(headerName, errorInformation.headers[headerName]);
                    });
                }
                this.statusCode = errorInformation.statusCode;
            }
            else {
                this.statusCode = 500;
                this.addResponseHeader('content-type', 'text/plain');
                this.setResponseData(errorInformation.message);
            }
        }
    }
    setResponseData(data) {
        this.responseData = data;
    }
    setContext(context) {
        this.context = context;
    }
    getResponseData() {
        if (this.messages.length) {
            this.addResponseHeader('sap-messages', JSON.stringify(this.messages));
        }
        if (this.dataAccess.getMetadata().getVersion() === '4.0') {
            this.addResponseHeader('odata-version', '4.0');
        }
        else {
            this.addResponseHeader('dataserviceversion', '2.0');
            this.addResponseHeader('cache-control', 'no-store, no-cache');
        }
        if (typeof this.responseData === 'string') {
            return this.responseData;
        }
        if (typeof this.responseData === 'number' && this.isCountQuery) {
            this.addResponseHeader('content-type', 'text/plain');
            return this.responseData.toString();
        }
        if (this.dataAccess.getMetadata().getVersion() === '4.0') {
            if (this.statusCode === 204) {
                return;
            }
            if (this.isMinimalRepresentation) {
                this.statusCode = 204;
                this.addResponseHeader('preference-applied', 'return=minimal');
                return null;
            }
            else {
                this.addResponseHeader('content-type', 'application/json;odata.metadata=minimal;IEEE754Compatible=true');
                let outContext = this.context || '';
                if (outContext.indexOf('$metadata') === -1) {
                    outContext = `$metadata#${this.context}`;
                }
                let resultObject = {
                    '@odata.context': outContext
                };
                const metadataETags = this.dataAccess.getMetadata().getETag();
                if (metadataETags) {
                    resultObject['@odata.metadataEtag'] = metadataETags;
                }
                if (Object.keys(this.responseAnnotations).length) {
                    resultObject = { ...resultObject, ...this.responseAnnotations };
                }
                if (Array.isArray(this.responseData)) {
                    resultObject['@odata.count'] = this.dataCount;
                    resultObject.value = this.responseData;
                }
                else {
                    resultObject = { ...resultObject, ...this.responseData };
                }
                return JSON.stringify(resultObject);
            }
        }
        else {
            if (this.statusCode === 204) {
                return;
            }
            this.addResponseHeader('content-type', 'application/json');
            // V2
            const resultObject = { d: {} };
            if (Array.isArray(this.responseData)) {
                resultObject.d.__count = this.dataCount;
                resultObject.d.results = this.responseData;
            }
            else {
                resultObject.d = this.responseData;
            }
            return JSON.stringify(resultObject);
        }
    }
    addMessage(code, message, severity, target) {
        this.addCustomMessage({ code, message, numericSeverity: severity, target });
    }
    addCustomMessage(messageData) {
        this.messages.push(messageData);
    }
    addResponseHeader(headerName, headerValue, globalHeader = false) {
        if (globalHeader) {
            this.globalResponseHeaders[headerName] = headerValue;
        }
        else {
            this.responseHeaders[headerName] = headerValue;
        }
    }
    addResponseAnnotation(annotationName, annotationValue) {
        this.responseAnnotations[annotationName] = annotationValue;
    }
    setDataCount(dataCount) {
        this.dataCount = dataCount;
    }
    addExpandForFilters(filterDefinition) {
        function expandPath(path, expands, lambdaVariable, skipLast) {
            var _a;
            const segments = path.split('/');
            if (segments[0] === lambdaVariable) {
                segments.shift();
            }
            if (skipLast) {
                segments.pop();
            }
            let target = expands;
            for (const segment of segments) {
                target[segment] = (_a = target[segment]) !== null && _a !== void 0 ? _a : {
                    expand: {},
                    properties: { '*': true },
                    removeFromResult: true
                };
                target = target[segment].expand;
            }
            return target;
        }
        function expand(expression, expandDefinitions, lambdaVariable) {
            var _a;
            if (typeof expression.identifier === 'string') {
                expandPath(expression.identifier, expandDefinitions, lambdaVariable, true);
            }
            else if (((_a = expression.identifier) === null || _a === void 0 ? void 0 : _a.type) === 'lambda') {
                const target = expandPath(expression.identifier.target, expandDefinitions, lambdaVariable);
                for (const subExpression of expression.identifier.expression.expressions) {
                    expand(subExpression, target, expression.identifier.key);
                }
            }
        }
        filterDefinition.expressions.forEach((expression) => expand(expression, this.expandProperties));
    }
}
exports.default = ODataRequest;
//# sourceMappingURL=odataRequest.js.map